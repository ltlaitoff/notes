**Event loop** - це деякий нескінчений цикл в [[JavaScript]] [[Runtime Environment]], наприклад, браузері або NodeJS, який виконує [[Task and Task queue|макрозадачі]], [[Мікрозадачі|мікрозадачі]] та [[Рендер]] інформації в браузері

### Навіщо потрібен Event loop

Річ у тому, що [[JavaScript Engine]] та [[JavaScript]] насправді не можуть викликати деякий код через деякий час, або ж робити асинхронні виклики кудись, відстежувати натискання по кнопках тощо. Фізично, в Engine немає підтримки цього!

Тому такий функціонал реалізує JavaScript [[Runtime Environment]], тобто браузер, або щось інше. Для простоти далі буде браузер, але це може бути і інше!

Розглянемо код з [[setTimeout]], який є гарним прикладом функції з [[Runtime Environment]] та спробуємо зрозуміти як воно працює та чому

```js
console.log('a')

setTimeout(() => {
	console.log('b')
}, 1000)

console.log('c')
```

Коли цей код викликається в [[Call stack]] додається контекст виклику(далі `main`), а також функції по одній

Це буде виглядати якось так

Спочатку запускається програма, тобто `main`

Далі викликається функція `console.log`, яка додається в `call stack` і після виконання пропадає з нього

Далі викликається функція `setTimeout`, яка є внутрішньою функцією браузера, детальніше нижче. І після вона пропадає

Далі знову викликається log

Весь Call stack буде виглядати якось так:

| Stack | Stack   | Stack | Stack      | Stack | Stack   | Stack | Stack |
| ----- | ------- | ----- | ---------- | ----- | ------- | ----- | ----- |
|       |         |       |            |       |         |       |       |
|       | log "a" |       | setTimeout |       | log "b" |       |       |
| main  | main    | main  | main       | main  | main    | main  |       |

Після виклику `setTimeout` браузер розуміє, що цей код треба викликати через 1 секунду. Щоб викликати щось використовується поняття [[Макрозадача]], або ж просто задача. Коли браузер хоче, щоб наш код щось виконав, наприклад, setTimeout або ж викликати callback функцію після події, він додає цю задачу в [[Task queue|чергу задач]], яку ще називають **Callback queue**

Далі Event loop буде виконувати ці задачі одну за одною

Умовою виконання задач є відстуність коду, який працює прямо зараз. Тобто відсутність елементів в [[Call stack]]!

Коли Call stack пустий, event loop бере одну макро задачу та виконує її

Якщо їх декілька - вони будуть виконуватись окремо, можливо через деякий час

Чи може бути ситуація, коли ми викликати setTimeout з 1с, а браузер викликав її через більшу кількість часу? ТАК, якщо виконуються інші задачі!
