
Для реалізації Binary search використовують два індекси

Перший, або `low`, вказує на початок діапазону в масиві, в якому ми зараз шукаємо значення

Другий, або `high`, вказує на кінець діапазону

Поки перший показник менший, а ніж другий, або дорівнює йому - ми продовжуємо пошук. Як тільки перший буде більшим за другий, і якщо елемента не знайдено - елемента немає в масиві

Для кожного діапазону ми вираховуємо елемент, який стоїть в середині

Для цього спочатку вираховується середнє значення між першим та другим індексом - `mid`

> [!important]
> Важливо, щоб це значення `mid` було **int**, бо воно буде використовуватись як індекс масиву, щоб потім брати значення
> 
> Є два основних варіанти знаходження середнього значення:
> - `(low + high) / 2`
> - `low + (high - low) / 2` - Краще використовувати цей
> 
> В першому варіанті є проблема - він може вийти за значення `int`, оскільки ми додаємо high + low
> 
> В другому варіанті такої проблеми немає, оскільки `high >= low`, а потім ще й ділиться на 2

Тепер використовуючи це середнє значення `mid`, яке є індексом елемента по середині діапазону, ми перевіряємо цей елемент

Якщо він дорівнює тому, який ми шукаємо - пошук завершений

Якщо його значення більше, а ніж те, яке ми шукаємо - нам треба взяти діапазон між `low` та `mid - 1`. Для цього ми `high` індекс ставимо в значення `mid - 1`. 

Якщо його значення менше - ставимо значення `low` в `mid + 1`

`+1` та `-1` тут потрібні, оскільки ми вже перевірили середній елемент та його можна пропустити

Приклади реалізації цього алгоритму на різних мовах програмування - [github](https://github.com/ltlaitoff/algorithm/tree/main/binary-search)

Якщо ми будемо змінювати присвоєння та перевірки - ми можемо досягти багатьох цікавих результатів

Наприклад:

[[Binary search для першого входження в масив]]
[[Binary search для останього входження в масив]]