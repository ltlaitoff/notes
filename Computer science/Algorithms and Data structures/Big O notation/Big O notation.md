`Big O` notation - це нотація, яка показує наскільки сильно росте кількість операцій, яку виконує алгоритм, при збільшенні кількості елементів

Більшість алгоритмів займають різний час при збільшенні кількості елементів. Але деякі з них стають набагато повільнішими, а деякі зовсім трошки

Це пов'язано з тим, що час роботи алгоритмів зростає з різною швидкістю при збільшенні кількості елементів. І ми хочемо побачити саме цю швидкість, а не час!

> [!tldr]
> Ця нотація **не показує час**, за який виконується алгоритм!
> 
> Натомість `Big O` **показує кількість операцій, яку виконує алгоритм, відносно кількості вхідних елементів**

> [!info] Syntax
> `O(operation)` - синтаксис `Big O`
> 
> Наприклад: `O(n)`, або `O(log n)`

На початку пишеться велика буква `O`, тому ця нотація і називається `Big O`, буквально

А в дужках пишеться кількість операцій

Якщо кількість операцій залежить від кількості елементів на вході, то тоді використовують, зазвичай, букву `n`. Більшість алгоритмів виконують різну кількість операцій при різній кількості вхідних даних

Якщо ж кількість операцій НЕ залежить від кількості елементів на вході, тобто вона константна, записують число. Наприклад, в [[HashMap]] ми отримуємо значення через ключ завжди за константний час

> [!note] Примітка
> Іноді в `Big O` замість кількості операцій говорять час, але все одно мають на увазі саме кількість операцій
> 
> Або ж іноді також говорять про "складність", наприклад "Складність такого алгоритму O(n^2)" -- я не впевнений, що це корректно

Існують деякі "стандартні Big O", але насправді їх список не обмежений

- [[O(1)]] - Константний час
- [[O(log n)]] - Логарифмічний час
- [[O(n)]] - Лінійний час
- [[O(n log n)]] - Лінійний час помножений на логарифмічний
- [[O(n^2)]] - Кубічний час
- [[O(n!)]] - Факторіальний час

### Приклад та порівняння швидкостей

Наприклад, нам треба намалювати 16 квадратів на папері

Щоб зробити це ми можемо використовувати різні підходи

Перший, і найпростіший підхід це малювання кожного квадрату окремо
В такому підході наш алгоритм виконає 16 операцій

Другий підхід - малювати лінії через весь аркуш паперу відразу
В такому підході нам треба намалювати 4 лінії: 2 вертикальні та 2 горизонтальні

Тепер збільшимо кількість елементів з 16 до 1024

В першому варіанті нам треба малювати все ще 1024 квадратів! Тобто, такий алгоритм має складність [[O(n)]]

А в другому підході всього 16 ліній! Тобто такий підхід має складність [[O(log n)]]

Задача одна, рішення також одне, але кількість операцій, а тому й час, зовсім різний. І він росте по різному при збільшенні кількості елементів

Ми можемо показати це на ось такій табличці, в якій умовно система може виконувати 10 операцій на секунду:

![[Compare base Big O.png]]

Деякі алгоритми зі збільшенням кількості операцій займають набагато більше часу, а ніж інші

Повноцінне визначення Big O було описано в книзі [[Grokking Algorithms]]